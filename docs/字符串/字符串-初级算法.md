## 1.反转字符串

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 char[] 的形式给出。

不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 ASCII 码表中的可打印字符。

示例 1：

> 输入：["h","e","l","l","o"]
> 输出：["o","l","l","e","h"]

示例 2：

> 输入：["H","a","n","n","a","h"]
> 输出：["h","a","n","n","a","H"]

[官方解答](https://leetcode-cn.com/problems/reverse-string/solution/fan-zhuan-zi-fu-chuan-by-leetcode-solution/)

我的解题：[完整代码仓库地址](https://github.com/IsMrChen/algorithmCode/blob/master/src/main/java/com/algorithm/string/RotateString.java)

解题思路：利用双指针

```java
class Solution {
    public void reverseString(char[] s) {
         int p = 0;
        int q = s.length-1;
        char temp = 0;
        for(int i=0;i<=(s.length-1)/2;i++){
            temp = s[p];
            s[p] = s[q];
            s[q] = temp;
            p++;
            q--;
        }
    }
}
```

## 2.整数反转

给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。

如果反转后整数超过 32 位的有符号整数的范围 [−231,  231 − 1] ，就返回 0。

假设环境不允许存储 64 位整数（有符号或无符号）。


示例 1：

> 输入：x = 123
> 输出：321

示例 2：

> 输入：x = -123
> 输出：-321

示例 3：

> 输入：x = 120
> 输出：21

示例 4：

> 输入：x = 0
> 输出：0


提示：

> -2^31 <= x <= 2^31 - 1

[官方解题](https://leetcode-cn.com/problems/reverse-integer/solution/zheng-shu-fan-zhuan-by-leetcode/)

我的解题：[完整代码仓库地址](https://github.com/IsMrChen/algorithmCode/blob/master/src/main/java/com/algorithm/string/IntegerInversion.java)

**解题思路：**

例如123 变成321

就是每一次循环数除以10取余，然后下一次循环这个数要*10

123

第一次循环取余为3  num=3

第二次循环取余为2  num=3*10+2=32

第三次循环取余为1  num=32*10+1=321

那么这里还需要注意的一点是 如果是-123我们要变成-321

那么就需要判断，如果数字为负值，我们要将符号先放一边，按照正数去翻转，然后再用结果*符号

int最大值是2147483647，最小值是-2147483648

因此我们需要判断是否溢出的问题

判断溢出，实际上我们只需要判断最后一次循环前num的值是否溢出就可以了，因为最后一次加法肯定不会进位

```java
class Solution {
    public int reverse(int x) {
        if(x==0){
            return 0;
        }
        int symbol = 1; //符号
        if(x<0){
            x=-x;
            symbol = -1;//符号为负
        }
        int num = 0;
        int p =0;
        while(x>0){
            //判断溢出
            if((num*10)/10!=num){
                num = 0;
                break;
            }
            p=x%10;
            x=x/10;
            num=num*10+p;
        }
        return symbol*num;//符号为负
    }
}
```

